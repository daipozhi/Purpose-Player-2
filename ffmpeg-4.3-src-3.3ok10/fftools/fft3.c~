
/*------  fft -------------------------------------------------------------

       fourierf.c  -  Don Cross <dcross@intersrv.com>

       http://www.intersrv.com/~dcross/fft.html

       Contains definitions for doing Fourier transforms
       and inverse Fourier transforms.

       This module performs operations on arrays of 'double'.

----------------------------------------------------------------------------*/


static int deb_fft3_fft_float( long    NumSamples,
			     float *RealIn,
		             float *RealOut,
		             float *ImagOut )
{
   long NumBits;    /* Number of bits needed to store indices */
   long i,j,k,n;
   long BlockSize, BlockEnd;

   float angle_numerator=(float)(2.0*DDC_PI);
   float delta_angle;
   float alpha, beta;  /* used in recurrence relation */
   float delta_ar;
   float tr, ti;       /* temp real, temp imaginary   */
   float ar, ai;       /* angle vector real, angle vector imaginary */

   if ( !deb_fft3_IsPowerOfTwo(NumSamples) ) return(1);

   if (deb_fft3_CheckPointer(RealIn )) return(1);
   if (deb_fft3_CheckPointer(RealOut)) return(1);
   if (deb_fft3_CheckPointer(ImagOut)) return(1);

   NumBits=deb_fft3_NumberOfBitsNeeded(NumSamples);

   /*
   **   Do simultaneous data copy and bit-reversal ordering into outputs...
   */

   for ( i=0; i < NumSamples; i++ )
   {
      j = deb_fft3_ReverseBits(i,NumBits );

      RealOut[j]=RealIn[i];
      ImagOut[j]=0;
   }

   /*
   **   Do the FFT itself...
   */

   BlockEnd = 1;
   for ( BlockSize = 2; BlockSize <= NumSamples; BlockSize <<= 1 )
   {
      delta_angle =angle_numerator/(float)BlockSize;
      alpha =sin((float)0.5*delta_angle);
      alpha =(float)2.0*alpha*alpha;
      beta  =sin(delta_angle);

      for ( i=0; i < NumSamples; i += BlockSize )
      {
	    ar = 1.0;   /* cos(0) */
	    ai = 0.0;   /* sin(0) */

	    for ( j=i, n=0; n < BlockEnd; j++, n++ )
		{
	      k = j + BlockEnd;
	      tr = ar*RealOut[k] - ai*ImagOut[k];
	      ti = ar*ImagOut[k] + ai*RealOut[k];

	      RealOut[k] = RealOut[j] - tr;
	      ImagOut[k] = ImagOut[j] - ti;

	      RealOut[j] += tr;
	      ImagOut[j] += ti;

	      delta_ar = alpha*ar + beta*ai;
	      ai -= (alpha*ai - beta*ar);
	      ar -= delta_ar;
		}
      }

      BlockEnd = BlockSize;
   }

   return(0);
}

static int deb_fft3_ifft_float(long     NumSamples,
			     float  *RealIn,
		             float  *RealOut,
		             float  *ImagOut )
{
   long NumBits;    /* Number of bits needed to store indices */
   long i,j,k,n;
   long BlockSize, BlockEnd;

   float angle_numerator=(float)(2.0*DDC_PI);
   float delta_angle;
   float alpha, beta;  /* used in recurrence relation */
   float delta_ar;
   float tr, ti;       /* temp real, temp imaginary   */
   float ar, ai;       /* angle vector real, angle vector imaginary */
   float denom;

   if ( !deb_fft3_IsPowerOfTwo(NumSamples) ) return(1);

   angle_numerator = -angle_numerator;

   if (deb_fft3_CheckPointer(RealIn )) return(1);
   if (deb_fft3_CheckPointer(RealOut)) return(1);
   if (deb_fft3_CheckPointer(ImagOut)) return(1);

   NumBits=deb_fft3_NumberOfBitsNeeded(NumSamples);

   /*
   **   Do simultaneous data copy and bit-reversal ordering into outputs...
   */

   for ( i=0; i < NumSamples; i++ )
   {
      j = deb_fft3_ReverseBits(i,NumBits );

      RealOut[j]=RealIn[i];
   }

   for ( i=0; i < NumSamples; i++ ) RealIn[i]=ImagOut[i];

   for ( i=0; i < NumSamples; i++ )
   {
      j = deb_fft3_ReverseBits(i,NumBits );

      ImagOut[j]=RealIn[i];
   }

   /*
   **   Do the FFT itself...
   */
    
   BlockEnd = 1;
   for ( BlockSize = 2; BlockSize <= NumSamples; BlockSize <<= 1 )
   {
      delta_angle =angle_numerator/(float)BlockSize;
      alpha =sin((float)0.5*delta_angle);
      alpha =(float)2.0*alpha*alpha;
      beta  =sin(delta_angle);

      for ( i=0; i < NumSamples; i += BlockSize )
      {
	    ar = 1.0;   /* cos(0) */
	    ai = 0.0;   /* sin(0) */

	    for ( j=i, n=0; n < BlockEnd; j++, n++ )
		{
	      k = j + BlockEnd;
	      tr = ar*RealOut[k] - ai*ImagOut[k];
	      ti = ar*ImagOut[k] + ai*RealOut[k];

	      RealOut[k] = RealOut[j] - tr;
	      ImagOut[k] = ImagOut[j] - ti;

	      RealOut[j] += tr;
	      ImagOut[j] += ti;

	      delta_ar = alpha*ar + beta*ai;
	      ai -= (alpha*ai - beta*ar);
	      ar -= delta_ar;
		}
      }

      BlockEnd = BlockSize;
   }

   /*
   **   Need to normalize if inverse transform...
   */

   denom=(float)NumSamples;

   for ( i=0; i < NumSamples; i++ )
   {
     RealOut[i] /= denom;
	 ImagOut[i] /= denom;
   }

   return(0);
}


static long deb_fft3_IsPowerOfTwo (long x )
{
   long i, y;

   for ( i=1, y=2; i < BITS_PER_WORD; i++, y<<=1 )
   {
      if ( x == y ) return(1);
   }

   return(0);

}


static long deb_fft3_NumberOfBitsNeeded(long PowerOfTwo )
{
   long i;

   if ( PowerOfTwo < 2 )
   {
      //fprintf ( stderr,
      //          ">>> Hosed in fftmisc.c: NumberOfBitsNeeded(%d)\n",
      //          PowerOfTwo );
      //
      //exit(1);
      return(1);
   }

   for ( i=0; ; i++ )
   {
      if ( PowerOfTwo & (1 << i) )
      {
	     return i;
      }
   }
}


static long deb_fft3_ReverseBits(long index,long NumBits )
{
   long i, rev;

   for ( i=rev=0; i < NumBits; i++ )
   {
      rev = (rev << 1) | (index & 1);
      index >>= 1;
   }

   return rev;
}

static float deb_fft3_Index_to_frequency (long NumSamples,long Index )
{
   if ( Index >= NumSamples )
   {
      return(0);
   }
   else
   {
     if ( Index <= NumSamples/2 )
	 {
       return((float)(Index/NumSamples));
	 }
     else
	 {
       return((float)(-(NumSamples-Index)/NumSamples));
	 }
   }
}

static int deb_fft3_CheckPointer(float *p)
{
   if ( p == NULL )
   {
      return(1);
   }
   return(0);
}



static int deb_fft3_thr(void)
{
  int   i,l,m,q;
  int   pcm;
  float d1;

  q=2;

  while(1)
  {
    if (fft_stt[q][0]!=1) av_usleep((int64_t)(0.01 * 1000000.0));
    else
    {
	  // transform to freq
	  i=deb_fft3_fft_float(FFT_BUFFER_SIZE,dlp_real_in1[q],dlp_real_ou1[q],dlp_imag_ou1[q]);
	  if (i!=0) continue;

	  // store to buffer for multi get
	  for (m=0;m<FFT_BUFFER_SIZE;m++)
	  {
		d1=get_dlp_real_ou1(q,m);
        	set_dlp_real_ou2(q,m,d1);
		d1=get_dlp_imag_ou1(q,m);
        	set_dlp_imag_ou2(q,m,d1);
	  }

          pcm=fft_stt[q][3];
          l  =fft_stt[q][2];

#if DPZ_DEBUG2
	  for (i=0;i<1;i++)
	  {
	    // 1st to 512th chn 
            m=deb_sr_fft_cx(i,pcm,l);
            if (m!=0) break;
	  }
#else
	  for (i=0;i<FFT_BUFFER_SIZE/2;i++)
	  {
	    // 1st to 256th chn 
            m=deb_fft3_cx(i,pcm,l);
            if (m!=0) break;
	  }
#endif
          fft_stt[q][0]=0;
    }
  }


  return(0);
}
 
static char m901_str1[300];

static int deb_fft3_cx(int chn,int pcm,int mark)
{
  float  d1;
  float  f1,f2;
  long   i,j,k,l,m,n,p,q;
  char   cc[6];
  //float  f1,f2;
  long long int lp;
  //char   str1[300];

  q=2;

  if ((chn<0)||(chn>=FFT_BUFFER_SIZE/2)) return(0);

#if DPZ_DEBUG2

  // get 1 of 3 chn data each times
  for (m=0;m<FFT_BUFFER_SIZE;m++)
  {
    f1=pcm*((float)m/(float)FFT_BUFFER_SIZE);

    if (deb_sr_fft_deb_chn==0) // to playback high freq , low freq ,middle freq ,to sure fft is ok
    {
    if (((f1>=deb_sr_frq[0])&&(f1<deb_sr_frq[28]))||
        ((f1>pcm-deb_sr_frq[28])&&(f1<=pcm-deb_sr_frq[0])))  // ??? > >= < <=

    //if (((m>=frq1)&&(m<frq2))||
    //    ((m>=FFT_BUFFER_SIZE-frq2)&&(m<FFT_BUFFER_SIZE-frq1)))

    {
	d1=get_dlp_real_ou2(m);
	set_dlp_real_in1(m,d1);
	d1=get_dlp_imag_ou2(m);
	set_dlp_imag_ou1(m,d1);
    }
    else
    {
	set_dlp_real_in1(m,0);
        set_dlp_imag_ou1(m,0);
    }
    }


    if (deb_sr_fft_deb_chn==1)
    {
    if (((f1>=deb_sr_frq[28])&&(f1<deb_sr_frq[49]))||
        ((f1>pcm-deb_sr_frq[49])&&(f1<=pcm-deb_sr_frq[28])))  // ??? > >= < <=

    //if (((m>=frq1)&&(m<frq2))||
    //    ((m>=FFT_BUFFER_SIZE-frq2)&&(m<FFT_BUFFER_SIZE-frq1)))

    {
	d1=get_dlp_real_ou2(m);
	set_dlp_real_in1(m,d1);
	d1=get_dlp_imag_ou2(m);
	set_dlp_imag_ou1(m,d1);
    }
    else
    {
	set_dlp_real_in1(m,0);
        set_dlp_imag_ou1(m,0);
    }
    }


    if (deb_sr_fft_deb_chn==2)
    {
    if (((f1>=deb_sr_frq[49])&&(f1<deb_sr_frq[70]))||
        ((f1>pcm-deb_sr_frq[70])&&(f1<=pcm-deb_sr_frq[49])))  // ??? > >= < <=

    //if (((m>=frq1)&&(m<frq2))||
    //    ((m>=FFT_BUFFER_SIZE-frq2)&&(m<FFT_BUFFER_SIZE-frq1)))

    {
	d1=get_dlp_real_ou2(m);
	set_dlp_real_in1(m,d1);
	d1=get_dlp_imag_ou2(m);
	set_dlp_imag_ou1(m,d1);
    }
    else
    {
	set_dlp_real_in1(m,0);
        set_dlp_imag_ou1(m,0);
    }
    }


  }

  // transform to pcm wave data
  i=deb_sr_ifft_float(FFT_BUFFER_SIZE,dlp_real_in1,dlp_real_ou1,dlp_imag_ou1);
  if (i!=0) return(1);


  // play back
  for (m=0;m<FFT_BUFFER_SIZE;m++)
  {
    f2=get_dlp_real_ou1(m);

    if (f2>=0) j=(int)(f2+0.5);
    else       j=(int)(f2-0.5);
    
    for (p=0;p<deb_sr_ch;p++)
    {
	if (p==0) deb_sr_fft_deb[deb_sr_fft_deb_pp2][m*deb_sr_ch+p]=j;
	else      deb_sr_fft_deb[deb_sr_fft_deb_pp2][m*deb_sr_ch+p]=0;
    }
  }

  deb_sr_fft_deb_pp2++;
  if (deb_sr_fft_deb_pp2>=4) deb_sr_fft_deb_pp2=0;

  if ((deb_sr_river_pp<0)||(deb_sr_river_pp>=200)) return(0);

  deb_sr_river[deb_sr_river_pp][chn]=n;
  deb_sr_river_mark[deb_sr_river_pp]=mark;

#else

  // get 1 of 512 chn data each times
  for (m=0;m<FFT_BUFFER_SIZE;m++)
  {
    //f1=pcm*((float)m/(float)FFT_BUFFER_SIZE);

    //if (((f1>=deb_sr_frq[chn])&&(f1<deb_sr_frq[chn+1]))||
    //    ((f1>pcm-deb_sr_frq[chn+1])&&(f1<=pcm-deb_sr_frq[chn])))  // ??? > >= < <=

    if ((m==chn)||(FFT_BUFFER_SIZE-1-m==chn))
    {
	d1=get_dlp_real_ou2(q,m);
	set_dlp_real_in1(q,m,d1);
	d1=get_dlp_imag_ou2(q,m);
	set_dlp_imag_ou1(q,m,d1);
    }
    else
    {
	set_dlp_real_in1(q,m,0.0);
        set_dlp_imag_ou1(q,m,0.0);
    }
  }

  // transform to pcm wave data
  i=deb_fft3_ifft_float(FFT_BUFFER_SIZE,dlp_real_in1[q],dlp_real_ou1[q],dlp_imag_ou1[q]);
  if (i!=0) return(1);

  // sum volumn
  f2=0.0;

  for (m=0;m<FFT_BUFFER_SIZE;m++)
  {
    f1=(int)get_dlp_real_ou1(q,m);
    if (f1<0.0) f1= 0.0-f1;
    f2=f2+f1;
  }

  #if DPZ_DEBUG1
  //sprintf(m901_str1,"fft cx,lp=%lld,",lp);
  //deb_record(m901_str1);
  #endif

  f2=f2/(float)FFT_BUFFER_SIZE;
  if (f2<0.0) f2=0.0;
  n=0;

  for (i=0;i<70;i++)  // a sound's db
  {
    if (f2>=deb_sr_db[i])
    {
      n=i;
      continue;
    }
    else break;
  }

  if (n<0  ) n=0;
  if (n>=70) n=69;

  p=fft_stt[q][1];

  if ((p<0)||(p>=1002)) return(0);

  deb_sr_river[p][chn]=n;
  deb_sr_river_mark[p]=mark;

  #if DPZ_DEBUG1
  //sprintf(m901_str1,"fft cx,river_pp=%d,chn=%d,val=%d,mark=%d,",deb_sr_river_pp,chn,n,mark);
  //deb_record(m901_str1);
  #endif

#endif
  return(0);
}

static float  deb_fft3_get_real_in1(long addr)
{
	if ((addr<0)||(addr>=FFT_BUFFER_SIZE)) return(0);
	return(dlp_real_in1[2][addr]);
}
static float  deb_fft3_get_real_ou1(long addr)
{
	if ((addr<0)||(addr>=FFT_BUFFER_SIZE)) return(0);
	return(dlp_real_ou1[2][addr]);
}
static float  deb_fft3_get_imag_ou1(long addr)
{
	if ((addr<0)||(addr>=FFT_BUFFER_SIZE)) return(0);
	return(dlp_imag_ou1[2][addr]);
}
static float  deb_fft3_get_real_ou2(long addr)
{
	if ((addr<0)||(addr>=FFT_BUFFER_SIZE)) return(0);
	return(dlp_real_ou2[2][addr]);
}
static float  deb_fft3_get_imag_ou2(long addr)
{
	if ((addr<0)||(addr>=FFT_BUFFER_SIZE)) return(0);
	return(dlp_imag_ou2[2][addr]);
}
static int  deb_fft3_set_real_in1(long addr,float val)
{
	if ((addr<0)||(addr>=FFT_BUFFER_SIZE)) return(0);
	dlp_real_in1[2][addr]=val;
	return(0);
}
static int  deb_fft3_set_real_ou1(long addr,float val)
{
	if ((addr<0)||(addr>=FFT_BUFFER_SIZE)) return(0);
	dlp_real_ou1[2][addr]=val;
	return(0);
}
static int  deb_fft3_set_imag_ou1(long addr,float val)
{
	if ((addr<0)||(addr>=FFT_BUFFER_SIZE)) return(0);
	dlp_imag_ou1[2][addr]=val;
	return(0);
}
static int  deb_fft3_set_real_ou2(long addr,float val)
{
	if ((addr<0)||(addr>=FFT_BUFFER_SIZE)) return(0);
	dlp_real_ou2[2][addr]=val;
	return(0);
}
static int  deb_fft3_set_imag_ou2(long addr,float val)
{
	if ((addr<0)||(addr>=FFT_BUFFER_SIZE)) return(0);
	dlp_imag_ou2[2][addr]=val;
	return(0);
}

